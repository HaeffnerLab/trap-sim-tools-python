¬¬¬¬¬¬¬¬trap-simulation-tools-python (by William)

1. Introduction

	This is the python version of the matlab code created by Nikos and Gebhart in 2010. It retains the same functionality and user interaction but its internal structure is different. While python is slower than matlab, it is more modular and easier for the typical user to understand. This guide can serve as a tutorial for either code, with special emphasis on the differences between the two. Do not edit any scripts other than project_parameters and analyze_trap without a complete understanding of what you are doing. Due to the different capabilities of matlab and python, analyze_trap contains volatile parameters in matlab while it only calls scripts in python. 
 
This particular ion trap simulation uses a linear combination of the potential fields from a collection of electrodes, typically 22. One is an RF electrode that oscillates and the rest are DC. The net DC potentials can also be described in terms of multipole expansions, typically to the second order. We would like to control the trapping field in by weighting the coefficients of each term. 

To do so, this software calculates the voltage of each electrode needed to create the desired field. Given an AutoCAD design, Kilian Singer’s BEM-solver software (or our synthetic generating function) creates a series of text files that describe the field in “simulations” (cubes of data points along the trapping axis). Our software then converts these text files to python “pickle” (.pkl) data structures. Next, we combine adjacent simulations to produce a single pickle centered on the trapping position. For the potential field of each electrode, we take a spherical harmonic expansion around the saddle point (or other extremum) and construct a matrix of the multipole coefficients of each to a given order. Finally, we calculates the least-square solutions to AX=B where A is the multipole coefficient matrix, each column of B corresponds to each multipole coefficient, and each column of X is a row of the output multipole controls. The multipole control matrix is saved as a text file to be used by the GUI. Afterwards, another script allows the user to plot the trapping field in numerous ways, and calculate parameters such as trap depth, and secular frequencies.

The software package includes three scripts: all_functions, project_parameters, and analyze_trap. The first is a library of all the functions used at the third, which runs all processes. The second is simply a list of parameters used by the functions, the most volatile of which may be moved to analyze_trap as it once was in the matlab code. 

2. Trap geometry

We have adapted this library for use with surface electrode traps, but should be able to use it with any other trap geometry. Our convention for numbering a trap with N electrodes, one of which is RF, is as follows: For a linear segmented trap, we start counting on the lower left corner. As you move up along the axis (staying on the same side of the RF rail you count up). When you reach the top, you cross to the right side of the RF rail and start counting at the bottom. When you reach the top, you cross to the inside of the RF rail and count DC electrodes from bottom to top. When you are done counting all the DCs, you count the RF electrode(s). Below is an example with N=12:
  _______________
|  05  | |      | |  10  | 
|____| |      | |____| 
|  04  | |      | |  09  | 
|____| |      | |____| 
|  03  | | 11 | |  08  | 
|____| |      | |____| 
|  02  | |      | |  07  | 
|____| |      | |____| 
|  01  | |       | |  06  | 
|____| |___| |____|


3. Multipole coefficients

	This is perhaps both the most important and the most confusing part of our software with respect to the differences between matlab and python. The multipole coefficients to the second order are the constant (const; often eliminated) weighting 1, the electric field components (Ex, Ey, and Ez) weighting x, y, and z, and the second order coefficients (U1 – U5) weighting (x2 – y2)/2, (2z2-x2-y2)/2, xy, yz, and xz respectively. The 2r0 and 2r02 in the denominators are ignored due to our selection of r0 = 1 meter for SI units. 

	Unfortunately, the mappings of these terms to their coefficients are complicated due to different methods of solving for them. Both the python and matlab codes calculate the coefficients in a different order than the desired sequence above. In matlab, the data is rearranged in expand_field with a matrix transformation. In python, the output of each spherical harmonic expansion is resorted. These reorganizations also come with some sign flips and weightings based on calibration with ideal potentials made from multipoles. In most cases, only U1 and U2 will be used. U1 is the typical form of the RF potential, uniform along the trapping axis, while U2 is the typical form of the DC potential.

4. Defining parameters

	Before you begin running any scripts from analyze_trap, you must work through project_parameters to initialize the software and make sure that you are consistent. The matlab script should be self-explanatory, so we will discuss the python version here. First, we import numpy (numerical python module), datetime (for keeping track of when you use the scripts), and TreeDict (for creating data structures). Next, we define some SI units and universal parameters. Set save to 1 if you want to save anything you do. Set the attributes of debug to 1 if you are debugging or want to see some extra plots and data as you go along. 

	The first script run is import_data, which you must set system information for. In the future, test_text may be run before it, as described in part 5. For simulationDirectory, input a string that describes the location of the text files on your computer. For baseDataNames, state the name (string) of the text files you wish to use, excluding the number at the end (which identified the simulation). For projectName, pick a name (string) of your choice that subsequent data structures will be saved as. Set useDate to 0 if you do not want to save the date and time you used the tools. Set simCount to be a 2-elemnt array of integers that describes the number of the first simulation to begin importing from and the total number of simulations to import. Set a single integer value for dataPointsPerAxis for the number of data points along the X and Y axes of the trap (which should be the same). Set an integer value for the number of electrodes (including the RF) excluding the number grounded. For savePath, input a string that describes the directory you wish to have data saved at. Finally, define the convention used by the text files. For test data, use [0,1,2], the default order. Spatially, the first index, X, is the radial direction, the second, Y is the height, and the third, Z, is along the trapping axis (axial). If the initial geometry is Euro trap, use [1,2,0]. If it is SQIP D trap or GG trap, use [0,2,1]. 

	The second script run is get_trap, which combines the data structures made from the text files around the trapping position to create a data structure representing the trap. For position, state the axial coordinate where the ion is located. This should be a grid value, not an index. Set zMin and zMax to be the grid values at either end of the entire trap, not a single simulation. Set zStep to be an integer value for the number of data points between each simulation. In theory, this should be the same as dataPointsPerAxis, which is indirectly checked by get_trap. Typically, name is set to projectName, but may also be set to filename (which includes the date if useDate is 1) or a new string of your choice.

	The third script run is expand_field, which builds the multipoleCoefficients matrix from the data and saves it as part of the trap’s configuration. Set the Xcorrection and Ycorrection to be how far offset the trapping position is from the RF saddle point, which is 0 by default. Set regenOrder to the degree to regenerate the data to. This parameter is by far the most relevant to the speed of the software, so keep it at 2 for slower computers. If speed is not an issue, it is generally 7. E is a 3-element array that describes the known electric field to correct for. 

	The fourth script run is trap_knobs, which builds the multipoleControls and saves them as a text file, officially ending the primary function of the software. Set expansionOrder to the order for the multipole expansion, which is almost always set to 2 for the coefficients described in section 3. Set reg to 1 if you want to regularize calculations (minimizing the norm of the vector of the kernel of multipole coefficients). If you have as many used electrodes as used multipoles, then the multipole matrices will be underdetermined, so you will need to set reg to 0. Next, you must define the electrode combinations. 

First, make electrodeMapping an array with a number of elements equal to the number of DC electrode. Each element is a two-element array with the first element the number of a physical electrode and the second the functional “electrode” it maps to. Each physical electrode must be the number of the DC electrode, in order, beginning from 1. If an electrode is grounded, set the second term to 0. If two physical electrodes map to the same functional one, then set the second element of each to be the same. Only adjacent electrodes may map to the same functional electrode. The numbering of the functional electrodes must begin at 1 and must not skip any integers. For example, if electrodes 1 and 2 are combined into one electrode, use [[1,1],[2,2],[3,2],[4,3], etc.]. 

For manualElectrodes, the indexing from 0 represents the DC electrodes starting from 1. For each manual electrode, set the appropriate index of this list to 1. If two physical electrodes map to the same functional electrode and you want that functional electrode to be manual, then you must set both physical electrodes to be manual as well. For usedMultipoles, make an array of length equal to the number of terms of the multipole expansion minus one (the constant term) and put a 1 for each element that is used. Reference the order of these multipoles discussed in section 3. 

Afterwards, project_parameters runs some tests to make sure that these variables were constructed correctly, raising errors if they were not. Finally, the script calculates the number of used electrodes by subtracting the grounded and combined electrodes from the total. It also subtracts the manual electrodes, but only the ones not already counted out by being part of a group of physical electrodes mapping to a manual functional electrode.

	The fifth and final script run is post_process_trap, which uses most of the volatile parameters listed in analyze_trap in the matlab code. The matlab code has a couple scripts before this, but they are all lower order functions called by this script in python. In the past, post_process_trap was used to for optimization subfunctions findCompensation and findEfield. Now, it only uses justAnalyzeTrap, while the other parameters exist to remind you of this fact. Set rfplot and dcplot to the string representing the type of plots you would like to see of the potential. If ‘1D plots’ is input, then you will see plots with 3 subplots, each a 1-dimensional plot of the potential with respect to each axis. If you input ‘2D plots’, then you will see sets of 3 animations; each a 2-dimensional plot of the potential, with each third axis presented as time. If you input ‘no plots’ or ‘both’, then you will see what you would expect.

	The next parameters are used to control trap operation. Set weightElectrodes to arrays of length equal to the number of DC electrodes with a value at each equal to the manual value of the respective manual electrode. Note that all electrodes set to 0 at manualElectrodes must also be set to 0 for weightElectrodes. This and other factors are then checked by statements in project_parameters. Set the mass equal to the mass of the trapped ion, generally 40*mp, the mass of a calcium ion (20 protons and 20 neutrons). Set the driveAmplitude and driveFrequency of the trap as appropriate (typically 100 mV and 40 MHz, respectively). These are used to weight the RF potential and calculate the pseudopotential to combine with the DC potential to determine the overall trapping field potential.

	The final section depends on if multipoleControls is set to 1. If not, then set the Mathieu alpha parameters ax and az, as well as phi, the angle of rotation of DC potential with respect to the RF multipole. These are typically -2e-3, 4.5e-3, and 0, respectively. Generally it will be set to 1, in which case you are free to manually request the multipole coefficients as described in section 3. The electric field coefficients are typically small negative numbers to counter whatever stray electric field is present. They can also be set equal to the components of E (defined in expand_field) for consistency, and are in units of V/mm**2. Finally, you reach the most volatile of all parameters, the quadrupole terms, in units of V/mm. The mapping of these coefficients is handled in the lower order spherical harmonic functions, and the conversion to SI units takes place here. 


5. BEM-solver text files

Before you use this package you must use a numerical electrostatics solver which returns the potentials of all the electrodes of a trap, stored in a text file with format X,Y,Z,V,Ex,Ey,Ez each line. X, Y, and Z refer to the spatial coordinate and V the potential at that coordinate. The Ex, Ey, and Ez terms refer to the electric field components at that point and are typically not included. It iterates through points in the order ZYX so as you scroll down, you will see each value of Z with X and Y constant, then Y will change to the next term and you will see the same cycle of Z. X is to Y as Y is to Z. 

You will notice that the text file continues even after this, returning to the point where it started. This new set of points corresponds to the potential field of the next electrode. Each text file begins with the RF electrode and then begins counting DC electrodes. Due to the limitations of BEM-solver, each file covers a “cube” of points, with dimensions of equal length. Previous software may have had unequal spacing between coordinates, but BEM-solver eliminates this as well. The trap itself is more like a rectangular “cylinder” along the trap axis, broken up into simulations. You will observe that the set of X and Y values remain the same for each simulation, while the Z values change. However, the first Z-value of each simulation must be the same as the last of the prior one.

You can find examples of these text files listed as “eurotrap-pt#” where the # refers to the simulation number (#=0 is empty). In matlab, there is a script generate_synthetic_data that can create simulations with a given number of electrodes and a multipole coefficient matrix. However, it is for debugging purposes and should not be changed.

In python, you can also make text files with the script test_text, designed for debugging. As of 5/25/14, it generates 2 simulations, each with 14 electrodes, with a saddle point where the two intersect. As of 6/1/14, it uses multipoles up to the second order and creates an escape position with a nonlinear term added to the RF potential. This nonlinear term is small enough to retain the same saddle point but large enough to create an escape position and trap depth. This function will be edited to allow the user to define text files of their own via project_parameters, but for now we will only describe how we produces the data. As of 6/5/14, there is a calibration option in project_parameters that should also be limited to debugging purposes. It is used to manually define the mapping in the sphere_harm functions. 

We produce text files in the format described above by iterating through each axis and calculating the potential field at each point directly from the equation of each electrode. The equation of each electrode is defined by a particular sum of multipole terms. First, the RF electrode is simply U1. Next, the 2nd through 4th ones are Ex, Ey, and Ez, respectively. Finally, the remaining electrodes are combinations of two Ui, beginning U1+U2 and ending U4+U5.

6. Importing text files
	
	The first real step to the process is to import the data from the text files into “TreeDict” python data structures to be used by the later functions. Day-to-day usage will only involve messing around with analyze_trap and project_parameters. You should not have to look inside this function, unless you are trying something new (and possibly inappropriate). To do this task, uncomment import_data() in analyze_trap and then run it, after making sure that everything is set appropriately in project_parameters. This set of tasks is the same for the other four top level scripts (get_trap, expand_field, trap_knobs, and post_process_trap) with the only difference being the order they must be run. While it is possible to run all 5 at once, you will rarely have to run the first more than once for a specific trap simulation and you will run last more frequently than the other three (which typically run together). We will describe these five functions in excruciating detail here, but will only glaze over the lower order functions as they are used.

This script reads the text files which your BEM solver simulations generated, and converts them to a .pkl structures. It does not make any changes to the structure 'trap', the job of the next function. The most important prerequisite is that consecutive BEM solver simulations must have overlapping first and last axial positions as discussed above. Each simulation is a "cube" of data points, each with a number of coordinates along Z equal to the full lengths of X and Y each, due to BEM-solver limitation. Always be sure that you are using the proper permutation at project_parameters.

After importing the necessary system information and modules, import_data iterates through the simulation text files. For each, it checks if such a text file has already been imported. It does this with a recursive function fileCheck and relies on the errors raised when attempting to open files that do not exist. If the desired text file has not yet been imported, then it begins the core five-stage import process. 

First, it checks if there is a text file to import in the first place. If there is not, you will have to double check your system information and make sure that the files you wish to import are identified properly. We use the loadtxt function from numpy to import the text files as an array, with each row a row and each column separated by commas.

Second, we build the grid vectors X, Y, and Z from the values of the coordinates in the text files. X and Y will be the same for each simulation, while Z will be different. The first term of each Z vector must be equal to the last term of the previous one. Here, we also apply the coordinate permutation to accommodate different trap geometry conventions of text files.

Third, we each voltage value, into the appropriate point on each electrode. To do so, we define a simulation data structure struct as a TreeDict with attribute branches leading to each electrode. Many of the lines of this code are in case there is a triplet of electric field components as well as a potential field for each electrode. In all cases, the 0th electrode will be the RF electrode and the DC electrodes will begin counting at EL_DC_1. We also apply the permutation here to match the grid vectors. The mapping from the text file to the electrode points is defined by the lower and upper bounds (lb and ub) which may take some staring at to understand completely.

Fourth, we build the simulation data structures that we will save. We rename struct to sim and add the grid vectors and system information as attributes. We set the RF electrode to the 0th DC electrode (EL_RF to EL_DC_0) and apply the system information directly from project_parameters. In matlab, some of these variables are stored later as part of the trap configuration, but python stores them now because it is the first time they are used, and then again if necessary. 

Fifth, we save the simulation data structure as a matlab structure (same as default matlab data structures) or python pickle. We combine the savePath (directory), filename (arbitrary), and simulation number to name each pickle. The pickle method requires defining a variable (here, output, defined by name) to be a file created by open (you must use ‘wb’ as the second argument), then pickle.dump the simulation at the output location, and finally close the file. If you do not have a line to close the file, you may get errors. You do not need to use pprint for saving, so it is excluded.

	If debug is on for import_data, then you will plot 1D plots of for each electrode, for each simulation. This may create quite a few plots, so it should only be used as a sanity check. This plotting function, plot_potential, is discussed when used in get_trap in the next section.

7. Building trap simulations

The next  step is to combine the simulations into a single data structure (.m for matlab and pickle for python, as always) that acts as a single “simulation” centered on the trapping position. The script is called get_trapping_field in matlab and get_trap in python. In addition to carrying over the electrode potentials and making new grid vectors, (X and Y should stay the same of course) we create a new attribute “configuration” to store parameters specific to the trap layout. These will also be defined by the next two scripts, but the final only changes more volatile parameters. Note that if you change these non-volatile parameters in project_parameters after running all but the post_process_trap, then that script will still be using the saved values, specifically the trapping position, rather than the newly defined ones.

	After importing parameters and defining a TreeDict trapping field “tf”, this script carries out 10 tasks, described below. 
1.	We check to see if the number of overlapping data structures saved is the same as the number of simulations. This primarily serves as a sanity check as the actual calculations and parameters involved are redundant. If there is a problem, it raises an error and the code stops. If there is only one simulation, then it simply saves that one as the new data structure with the configuration added. Opening a pickle requires defining a variable file with the function open on the path and ‘rb’. We then create an attribute of tf “potentials” and use pickle.load on the file to define it. Next, we use file.close() to close the file and use the data.
2.	We define a background for all the files to be based on, defined by the axial grid vectors and values along this Z axis.
3.	We define and use a helper function that finds the index of the first element of a list that is larger than a given position. Matlab has an internal function for this. If the given trapping position is outside the overall grid, then we raise an error.
4.	We check which side of the simulation the trapping position is. We refer to the left as the lower Z-coordinate values and the right as the higher ones.
5.	If the position is in the left half of the first simulation, we return that one.
6.	If the position is in the right half of the last simulation, we return that one.
7.	Otherwise, we must rebuild a simulation from portions of the simulations on either side of the position. This is the most convoluted section of this script, so we divide it into parts as well:
a.	Define lower and upper bounds along the trapping axis and a variable “shift” that allows us to describe the number of indices we want to frame shift a hypothetical lower bound of the new simulation if it were initially in the same place as the left simulation.
b.	Open the simulation file left of the position.
c.	Open the simulation file right of the position.
d.	Create temporary structures that will be used to build up the composite simulation.
e.	Build up each electrode potential with complicated indexing that may require some staring at.
8.	Create the configuration attribute and apply the position, number of electrodes, and number of used electrodes as attributes of it. Note that the number of electrodes was also defined in import_data and that the number of used electrodes will be changed by trap_knobs based on the electrode mapping and manual electrodes.
9.	If debug, check if the field was generated successfully by plotting the axial axis for continuity and plotting each potential, like at the end of import_data, except that these are 2D plots instead of 1D ones. They may also be set to ‘1D plots’ and used casually without much concern if you just want to see what your field looks like before running the slowest function, expand_field. 
10.	Save the data structure as a single pickle.

The primary plotting function of this software is the script plot_potential. It takes in a 3D array, 3 grid vectors, a key for what type of plots (described earlier), and optionally a y-axis label, a title, and a point to plot around. If no point is given to plot around, it calls find_saddle (described in section 8) to determine what to use as the origin. It plots 1D sub plots on the same image, with X at the top left, Y at the top right, and Z at the bottom left and plots 2D animations by calling mesh_slice. The function mesh_slice takes in a 3D array, an axis to plot along, and plots an animation of successive slices along the given axis. It can also display a title that changes between frames, but it moves down the image as it animates.

8. Expanding trapping field

	The following process is by far the most time consuming of all due to its many calls of the sphere_harm functions and exact_saddle. The highest order function, expand_field, does the spherical harmonic expansion of the potentials for all the used electrodes. It then stores the harmonic expansion coefficients (excluding that of the RF) in the trap configuration as the variable multipoleCoefficients. Typically, expand_field will also compute all the potentials from the spherical harmonic coefficients and replace the original values with the computed ones. This can be useful as a data smoothing step so that the algorithms which use numerical derivatives (e.g. in post_process_trap for pseudopotential calculation, find_saddle, trap_depth) work better. 
	
	This script begins with a lengthy definition of parameters, using both trap attributes and project_parameters. It also imports numerous lower order functions including the sphere_harm ones, the saddle ones, plot_potential, and dc_potential. If you have already expanded the field and are not debugging, then the script stops and lets you know. Should this trouble you, just run get_trap again. If there is no attribute of the trap “instance” (which there should not be the first time this is run) then it calls dc_potential with trivial inputs to construct an instance configuration. This is basically a sum of all electrodes potentials that describes the overall DC potential based on given weightings of manual and normal DC electrodes. Here, that weighting is defined to be all 1, with no manual electrodes. Finally, we note the order of the expansion and the number of terms this entails. In most cases, we will want a second-order expansion, which means 9 terms.
	
The saddle and sphere_harm functions are pivotal to the core of this script, so we will discuss them first. The function find_saddle takes the gradient (electric field) of a potential field and minimizes it to find the saddle point. It returns the index of grid vector corresponding to the saddle point. In contrast, exact_saddle calculates the exact position of the saddle. It does this by minimizing the electric field defined by the function sum_of_e_field, which adds up the electric field coefficients of the multipole expansion and divides them by the quadrupole coefficients. Toggling debug to 1 allows you to view the optimization process. If there is no satisfactory saddle point, it states so and then returns the closest candidate. While find_saddle finds the index of the saddle along the grid vectors, exact_saddle returns the value of the grid vectors them.

	To find the multipole coefficients, sum_of_e_field must call spher_harm_exp (short for expansion) which uses least-square regression on a 3D potential to solve for the coefficients by inverting each term of the spherical harmonic expansion around each point in the array. We then apply an artificial mapping and reweighting to the coefficients just before they are output in order to match the desired multipole notation (discussed in section 3). The matlab code applies its own mapping elsewhere in expand_field. Issues with python libraries caused the method for solving the coefficients to be designed more intuitively, but also slower. The script spher_harm_cmp (comparison) inverts what the expansion does and mirrors the potential along two axes (in python). Due to this, we use flipup and fliplr in python each time it is called. Finally, spher_harm_qlt (quality) is a debugging function that runs exp and cmp on the same data set to check the quality of the expansion. On synthetic data, it can be as low as order 10-15 but real data can reach as high as 10-3, even with internal optimization.

	The first major action of expand_field is to expand and regenerate the RF potential about the center of the grid. Note that this is not necessarily around its saddle point, but it usually is. By “regenerating” a potential, we mean to apply the sphere_harm functions to it and get a “smoothed out” potential that is very close. Debugging for this function displays the (1D) plots for these potentials after they are expanded. We then collect the multipole coefficients of the RF potential (about its saddle point this time) and configuration parameters Qrf and thetaRf through given mappings.

	Next, we repeat the process for each DC electrode. Note that we expand these around the RF saddle point in the same manner. We also build up the multipoleCoefficients matrix from the output of spher_harm_exp on each. Each row corresponds to an electrode and each column a multipole coefficient. There used to be an auxiliary function in this script called “normalize” but it is no longer in use by python. Finally, we save the multipoleCoefficients as a trap configuration attribute with the regenerated electrode potentials.
   
         
9. Outputting multipole controls

	The final script to run to get the text file for LabRad is trap_knobs, which calculates the “independent multipole control parameters” (see G. Littich Master's thesis for an explanation of what these are). < http://physics.berkeley.edu/research/haeffner/publications/littich-thesis.pdf> It also stores the kernel vectors of the multipoleControls space in the trap configuration, unless the multipoleControls are rank deficient (and thus will have no null space). This is also where the electrodeMapping and designation of manualElectrodes becomes relevant, as the pseudoinverse is computed with the redundant electrode multipoleCoefficients removed. As of 4/4/2014, the array is saved as Multipole_Control_File.txt, under the _post_processed folder in matlab, while in python it is saved where the text file simulationDirectory is.
	
	As usual, we begin by importing the relevant parameters and functions, and check if trap_knobs had already been run.  We also check to see if any row of electrodes in the multipoleCoefficients matrix is all zero, in which case we will have a missing multipole and be unable to solve the least-square to come. 

	Next, we call the function compact_matrix to remove all redundant electrodes, as defined by the electrode mapping and manual electrodes described in section 4. We also remove the first multipole coefficient from the overall matrix, the constant term, as we are not concerned about its weight. Then we build another matrix of the used multipoles without the coefficients, combining both reductions.	

	To create the multipoleControls, we must use least-square regression on the reduced coefficients matrix with artificially defined vectors that pick out single multipoles, for each multipole. If debugging is enabled, we use plotN on each multipole control, and display the error of the fit, for each multipole. Referencing the trap geometry (described in section 2), plotN displays the relative potential of each electrode corresponding to each multipole. For example, if DC electrodes 3, 6, and 9 have strong U2 terms compared to the rest, then the plotN for U2 will display them as tall and red in the 3D depiction of the trap geometry.

	We also reference a function from <http://wiki.scipy.org/Cookbook/RankNullspace> to calculate the null space in python (matlab has its own function). This null space is used to regularize the coefficient matrix. However, if there are fewer then the number of multipoles (plus one) electrodes, then the matrix is underdetermined and there can be no null space or regularization.

	Finally, we use expand_matrix_mult and expand_matrix_el to put the duplicate electrodes back into the multipoleControls matrix and save the data. The multipoleControls and Kernel are saved in the trap configuration and then the multipoleControls matrix is broken up into a single column of text data, iterating through the electrodes for each multipole coefficient first, and saved as a text file for LabRad.

10. Trap analysis post process

	After processing the trap, you can analyze it with the final higher order function, post_process_trap. This script is slightly misleading as most of its functionality is lost to its helper function pfit, which also calls numerous functions and will also be described in detail. Likewise, it has absorbed the script set_voltages, which refers to the scripts multipole_set_dc in matlab. The script set_voltages in matlab is not required by python. The script post_process_trap used to have other uses for optimization, with their own helper functions, but all that remains is the function d_e, which is used for finding the electric field compensation distance. Lastly, pfit calls p2d, numpy functions polyfit and polyval, and trap_depth, to return the instance configuration parameters that correspond to the volatile trap operation parameters.

	First, post_process_trap imports all the necessary parameters and functions. Then it builds a new trap instance with the output of set_voltages as the voltage weights for dc_potential (while the manual weights defined in project_parameters). The script set_voltages uses the multipoleControls matrix to determine the values to set each DC electrode to in order to create the field defined by the multipole coefficients given in project_parameters. We also create some internal variables from the imported and configuration variables to serve as “magic numbers” for calculations inside. Immediately, we rescale the amplitude of the RF potential. If we have debug on for this script, then we also plot it. 

	Next, we plot the weighted DC potential, with the stray field included. After reminding the user that findEfield and findCompensation are no longer in use, we use d_e to determine (and print) the stray E field the compensation distance. We also print the exact saddle points of the RF and DC potentials and plot the DC potential around the RF saddle point.

	Now, we leave the rest of the major actions to pfit. It begins by rebuilding all the necessary parameters not inherited from post_process_trap. It calculates a pseudopotential from the RF potential and electric fields, weights it, and combines it with the DC potential to make the net trapping field. All three of these are plotted in electron volts. Through numerous manipulations, pfit then constructs axes to send into p2d, which in turn finds the rotation angle between them and the coefficients of the second order polynomial fit. These parameters are then used to find the secular trap frequencies fx and fy via an analogy to harmonic motion. To find fz, it calls polyfit and polyval from numpy and makes a similar calculation. In the end, it references trap_depth to determine the potential difference between the escape point and the trapping (absolute saddle) point, as well as the position of the escape point. There is also a parameter superU that is constructed, but it is presently not used.

	Back to post_process_trap, we run a sanity check in place of an old quality check. We expand the DC with and without the RF and save numerous parameters in the data structure “out”. Finally, update the trap’s instance configuration with all of the new, volatile parameters and save it. 

Overall, this software gets the multipoleControls for the text files of a simulated trap and then analyzes it under fields defined in terms of multipole coefficients.
